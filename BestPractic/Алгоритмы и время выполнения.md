> Нотация O-большое -  описывает время выполнения алгоритма в **худшем случае**
___
#### STL-алгоритмы имеют свою сложность, нужно знать:
* `std::sort()` в C++ использует **Introsort** (гибрид Quicksort, Heapsort и Insertion sort), который гарантирует `O(n log n)` в худшем случае.
- `std::find()`: `O(n)` (линейный поиск)
- `std::binary_search()`: `O(log n)` (но требует отсортированного диапазона)
- `std::unordered_map::find()`: в среднем `O(1)`, в худшем `O(n)`
- `std::map::find()`: `O(log n)`
- `std::accumulate()`: `O(n)`
___
### Как определять сложность при использовании STL
1. **Читайте документацию**: [cppreference.com](https://cppreference.com/) всегда указывает сложность
2. **Понимайте структуры данных**:
    - Вектор/строка: индексация `O(1)`, поиск `O(n)`
    - `std::set`/`std::map`: основаны на красно-черных деревьях, операции `O(log n)`
    - `std::unordered_set`/`std::unordered_map`: хеш-таблицы, в среднем `O(1)`
___
