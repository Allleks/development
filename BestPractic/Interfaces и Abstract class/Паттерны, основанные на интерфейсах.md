Интерфейсы - это фундамент, на котором строятся почти все паттерны проектирования. Они обеспечивают гибкость, тестируемость и соблюдение принципа открытости/закрытости (OCP).
___
**1. Стратегия (Strategy)** - самый близкий к вашему примеру:
```cpp
class IDatabaseStrategy {
public:
    virtual void connect() = 0;
    virtual ~IDatabaseStrategy() = default;
};

class PostgreSQLStrategy : public IDatabaseStrategy { /*...*/ };
class SQLiteStrategy : public IDatabaseStrategy { /*...*/ };

class App {
    std::unique_ptr<IDatabaseStrategy> m_strategy;
public:
    void setStrategy(std::unique_ptr<IDatabaseStrategy> strategy) {
        m_strategy = std::move(strategy);
    }
    void run() {
        m_strategy->connect(); // полиморфный вызов
    }
};
```

**2. Фабрика (Factory) / Абстрактная фабрика:**
```cpp
// Ваш IRepositoriesManager - это Фабрика репозиториев!
class IRepositoryFactory {  // Аналог вашего IRepositoriesManager
public:
    virtual std::unique_ptr<IUserRepo> createUserRepo() = 0;
    virtual std::unique_ptr<IOrderRepo> createOrderRepo() = 0;
};

class SQLRepositoryFactory : public IRepositoryFactory { /*...*/ };
class FileRepositoryFactory : public IRepositoryFactory { /*...*/ };
```

**3. Мост (Bridge) - отделение абстракции от реализации:**
```cpp
class IDatabaseDriver {  // интерфейс реализации
    virtual void executeQuery(const std::string&) = 0;
};

class DatabaseConnection {  // абстракция
    std::unique_ptr<IDatabaseDriver> m_driver;
public:
    DatabaseConnection(std::unique_ptr<IDatabaseDriver> driver)
        : m_driver(std::move(driver)) {}
    
    void query(const std::string& sql) {
        m_driver->executeQuery(sql);
    }
};
```

**4. Адаптер (Adapter):**
```cpp
// Старый интерфейс
class ILegacyPrinter {
    virtual void printDocument(const char*) = 0;
};

// Новый интерфейс
class IModernPrinter {
    virtual void print(const std::string&) = 0;
};

// Адаптер
class PrinterAdapter : public IModernPrinter {
    ILegacyPrinter& m_legacy;
public:
    void print(const std::string& doc) override {
        m_legacy.printDocument(doc.c_str()); // адаптация
    }
};
```

**5. Наблюдатель (Observer) - очень популярен в Qt:**
```cpp
class IObserver {
public:
    virtual void update(const QString& data) = 0;
};

class Subject {
    QList<IObserver*> m_observers;
public:
    void attach(IObserver* obs) { m_observers.append(obs); }
    void notify(const QString& data) {
        for (auto obs : m_observers) {
            obs->update(data);  // полиморфный вызов
        }
    }
};
```

**В Qt особенно важны интерфейсы:**
```cpp
// Qt тоже использует интерфейсы (через чисто виртуальные методы)
class QAbstractItemModel {  // интерфейс для моделей
public:
    virtual QVariant data(const QModelIndex& index, 
                         int role = Qt::DisplayRole) const = 0;
    // ... другие чисто виртуальные методы
};

// Ваша реализация
class MyModel : public QAbstractItemModel {
public:
    QVariant data(const QModelIndex& index, int role) const override {
        // ваша реализация
    }
    // ... реализация остальных методов
};
```
