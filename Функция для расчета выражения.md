```cpp
void EditExpressionWindow::calculateClicked()
{
    try
    {
        expressionResult = ui.expressionInput_textEdit->toPlainText().trimmed();
        
        if (expressionResult.isEmpty())
        {
            QMessageBox::warning(this, windowTitle(), "Введите выражение");
            return;
        }

        QTableWidget* table = ui.expression_table_2;
        auto propertyValue = getPropertyMapFromTable(table);

        if (propertyValue.empty())
        {
            QMessageBox::warning(this, windowTitle(),
                "Нет заполненных значений в таблице");
            return;
        }

        // ПРАВИЛЬНАЯ ПРОВЕРКА:
        
        // 1. Извлекаем переменные из выражения
        QRegularExpression re(R"(\{([^}]+)\})");
        QRegularExpressionMatchIterator i = re.globalMatch(expressionResult);
        
        QSet<QString> expressionVariables;
        while (i.hasNext())
        {
            QRegularExpressionMatch match = i.next();
            QString var = match.captured(1).trimmed();
            if (!var.isEmpty())
            {
                expressionVariables.insert(var);
            }
        }
        
        // 2. Если не нашли переменных в скобках, ищем просто слова
        if (expressionVariables.isEmpty())
        {
            // Простой поиск слов
            QStringList words = expressionResult.split(QRegularExpression("[^a-zA-Z0-9_]"), 
                                                      Qt::SkipEmptyParts);
            for (const QString& word : words)
            {
                // Пропускаем числа и зарезервированные слова
                bool isNumber;
                word.toDouble(&isNumber);
                if (!isNumber && !isMathFunction(word))
                {
                    expressionVariables.insert(word);
                }
            }
        }
        
        // 3. Проверяем, что ВСЕ переменные из выражения есть в таблице
        QStringList missingVars;
        for (const QString& exprVar : expressionVariables)
        {
            // Ищем переменную из выражения в propertyValue
            if (propertyValue.find(exprVar.toStdString()) == propertyValue.end())
            {
                missingVars << exprVar;
            }
        }
        
        // 4. Если есть отсутствующие - ошибка
        if (!missingVars.isEmpty())
        {
            QMessageBox::warning(this, windowTitle(),
                QString("Отсутствуют значения для:\n%1\n\nЗаполните в таблице")
                .arg(missingVars.join(", ")));
            return;
        }

        // 5. Только теперь вычисляем
        QByteArray localData = expressionResult.toLocal8Bit();
        const std::string_view stdStr(localData.constData(), localData.size());
        
        auto propertyList = std::list<const std::map<std::string, 
            mcc::PropertyValue, std::less<>>*>{ &propertyValue };
        
        auto textExpressionResolver = mcc::TextExpressionResolver(nullptr);
        auto resolver = textExpressionResolver.ResolveExpression(stdStr, propertyList);
        
        if (auto result = resolver.GetValue())
        {
            ui.resultDisplay_textEdit->setText(
                QString::fromLocal8Bit(result->c_str()));
        }
    }
    catch (const std::exception& ex)
    {
        qCritical() << ex.what();
    }
}

bool EditExpressionWindow::isMathFunction(const QString& word)
{
    static const QSet<QString> mathFuncs = {
        "sin", "cos", "tan", "cot", "asin", "acos", "atan", "acot",
        "sinh", "cosh", "tanh", "coth", "exp", "log", "ln", "sqrt",
        "abs", "pow", "max", "min", "pi", "e"
    };
    return mathFuncs.contains(word.toLower());
}
```