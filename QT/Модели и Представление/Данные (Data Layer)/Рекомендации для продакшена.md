#### **DO:**
```cpp
// 1. Использовать репозитории для абстракции
class DataAccessLayer {
    virtual QVector<Operation> getOperations() = 0;
};

// 2. Кешировать данные в памяти
class CachedRepository : public DataAccessLayer {
    QCache<int, Operation> m_cache;  // LRU кеш
};

// 3. Использовать транзакции
bool saveOperations(const QVector<Operation>& ops) {
    m_db.transaction();
    try {
        for (auto& op : ops) saveOperation(op);
        return m_db.commit();
    } catch (...) {
        m_db.rollback();
        return false;
    }
}
```
#### **DON'T:**
```cpp
// 1. Не смешивать бизнес-логику и доступ к данным
// ПЛОХО:
void updateOperation(int id) {
    QSqlQuery query;  // SQL прямо в бизнес-логике
    query.exec("UPDATE ...");
    sendEmailNotification();  // И email тут же!
}

// 2. Не делать синхронные запросы в основном потоке
// ПЛОХО:
void loadData() {
    QSqlQuery query;
    query.exec("SELECT * FROM huge_table");  // Блокирует UI
    // ...
}
```
### **Асинхронная загрузка данных:**
```
class AsyncDataLoader : public QObject {
    Q_OBJECT
    
public slots:
    void loadOperations() {
        QtConcurrent::run([this]() {
            // В фоновом потоке
            auto data = m_repository->fetchAllOperations();
            
            // Возвращаем в главный поток
            QMetaObject::invokeMethod(this, [this, data]() {
                emit dataLoaded(data);
            });
        });
    }
    
signals:
    void dataLoaded(const QVector<Operation>& data);
};
```
### **Валидация данных перед загрузкой в модель:**
```cpp
class DataValidator {
public:
    static ValidationResult validateOperation(const Operation& op) {
        ValidationResult result;
        
        if (op.name.isEmpty()) 
            result.addError("Name cannot be empty");
            
        if (op.name.length() > 100)
            result.addError("Name too long");
            
        return result;
    }
};

// В модели:
bool OperationsModel::addOperation(const Operation& op) {
    auto validation = DataValidator::validateOperation(op);
    if (!validation.isValid()) {
        emit validationFailed(validation.errors());
        return false;
    }
    
    beginInsertRows(...);
    m_data.append(op);
    endInsertRows();
    
    return true;
}
```
### **Миграция данных (для БД):**
```cpp
class DatabaseMigrator {
public:
    void migrate(int fromVersion, int toVersion) {
        if (fromVersion < 2 && toVersion >= 2) {
            QSqlQuery query;
            query.exec("ALTER TABLE operations ADD COLUMN created_at TIMESTAMP");
        }
        
        if (fromVersion < 3 && toVersion >= 3) {
            QSqlQuery query;
            query.exec("CREATE INDEX idx_operations_name ON operations(name)");
        }
    }
};
```

### **Пример полной архитектуры:**
```cpp
// 1. Data Layer (нижний уровень)
class DatabaseManager {  // Синглтон
    bool initialize();
    QSqlDatabase& connection();
};

// 2. Repository Layer
class OperationRepository {
    QSqlDatabase& m_db;
    
    QVector<Operation> findAll() { /* SQL запросы */ }
    Operation findById(int id) { /* ... */ }
    bool save(const Operation& op) { /* ... */ }
};

// 3. Service Layer (бизнес-логика)
class OperationService {
    OperationRepository* m_repo;
    DataValidator* m_validator;
    
    bool createOperation(const QString& name) {
        Operation op(name);
        if (!m_validator->validate(op)) return false;
        return m_repo->save(op);
    }
};

// 4. Model Layer (для Qt View)
class OperationsTableModel : public QAbstractTableModel {
    OperationService* m_service;
    QVector<Operation> m_cachedData;
    
    void refresh() {
        beginResetModel();
        m_cachedData = m_service->getAllOperations();
        endResetModel();
    }
};
```